/*5151,820,3270,3491,10696,527,15073,213,600,5564,1356,833,7168,349,410,2908,2904,2781,5537,7454*//// <reference path="../../SDL.Client.Core/Libraries/jQuery/SDL.jQuery.d.ts" />
/// <reference path="../../SDL.Client.Core/Types/Types.d.ts" />
/// <reference path="../../SDL.Client.Core/Types/Array.d.ts" />
/// <reference path="../../SDL.Client.Core/Types/OO.d.ts" />
/// <reference path="../../SDL.Client.Core/Diagnostics/Assert.d.ts" />
/// <reference path="../../SDL.Client.Core/Resources/ResourceManager.d.ts" />
/// <reference path="../Controls/ControlBase.ts" />
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            (function (Renderers) {
                var ControlRenderer = (function () {
                    function ControlRenderer() {
                    }
                    ControlRenderer.renderControl = function (type, element, settings, callback, errorcallback) {
                        if (element) {
                            SDL.jQuery(element).data("control-create", true); // setting data to a value to be able to detect it when the element is removed from the DOM
                        }

                        SDL.Client.Resources.ResourceManager.load(type, function () {
                            if (!element || SDL.jQuery(element).data("control-create")) {
                                var ctor = ControlRenderer.types[type];
                                if (!ctor) {
                                    ctor = ControlRenderer.types[type] = ControlRenderer.getTypeConstructor(type);
                                }

                                if (!element) {
                                    if (ctor.createElement) {
                                        element = ctor.createElement(document, settings);
                                    } else {
                                        element = document.createElement("div");
                                    }
                                }

                                // Instantiate the control
                                var control = new ctor(element, settings);

                                // Render control
                                control.render(callback ? function () {
                                    callback(control);
                                } : null, errorcallback);
                            }
                        });
                    };

                    ControlRenderer.onControlCreated = function (control) {
                        var type = control.getTypeName();
                        if (ControlRenderer.createdControls[type]) {
                            ControlRenderer.createdControls[type].push(control);
                        } else {
                            ControlRenderer.createdControls[type] = [control];
                        }
                    };

                    ControlRenderer.disposeControl = function (control) {
                        if (control.dispose) {
                            control.dispose();
                        }
                    };

                    ControlRenderer.onControlDisposed = function (control) {
                        var type = control.getTypeName();
                        if (ControlRenderer.createdControls[type]) {
                            SDL.Client.Types.Array.removeAt(ControlRenderer.createdControls[type], ControlRenderer.createdControls[type].indexOf(control));
                        }
                    };

                    ControlRenderer.getCreatedControlCounts = function () {
                        var createdControls = {};
                        SDL.jQuery.each(ControlRenderer.createdControls, function (type, controls) {
                            createdControls[type] = controls.length;
                        });
                        return createdControls;
                    };

                    ControlRenderer.getTypeConstructor = function (type) {
                        SDL.Client.Diagnostics.Assert.isString(type, "Control type name is expected.");

                        var ctor;
                        try  {
                            ctor = SDL.Client.Type.resolveNamespace(type);
                        } catch (err) {
                            SDL.Client.Diagnostics.Assert.raiseError("Unable to evaluate \"" + type + "\": " + err.description);
                        }
                        SDL.Client.Diagnostics.Assert.isFunction(ctor, "Unable to evaluate \"" + type + "\".");
                        return ctor;
                    };
                    ControlRenderer.types = {};
                    ControlRenderer.createdControls = {};
                    return ControlRenderer;
                })();
                Renderers.ControlRenderer = ControlRenderer;
                ;
            })(Core.Renderers || (Core.Renderers = {}));
            var Renderers = Core.Renderers;
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
;
//# sourceMappingURL=ControlRenderer.js.map
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            /// <reference path="../../SDL.Client.Core/Libraries/jQuery/jQuery.d.ts" />
            /// <reference path="../../SDL.Client.Core/Types/Object.d.ts" />
            (function (Controls) {
                function getInstanceAttributeName(control) {
                    return "data-__control__-" + SDL.Client.Types.Object.getUniqueId(control);
                }
                Controls.getInstanceAttributeName = getInstanceAttributeName;
            })(Core.Controls || (Core.Controls = {}));
            var Controls = Core.Controls;
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
//# sourceMappingURL=Base.js.map
/// <reference path="../../SDL.Client.Core/Libraries/jQuery/jQuery.d.ts" />
/// <reference path="../../SDL.Client.Core/Types/Types.d.ts" />
/// <reference path="../../SDL.Client.Core/Types/ObjectWithEvents.d.ts" />
/// <reference path="../Renderers/ControlRenderer.ts" />
/// <reference path="Base.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            (function (Controls) {
                eval(SDL.Client.Types.OO.enableCustomInheritance);
                var ControlBase = (function (_super) {
                    __extends(ControlBase, _super);
                    function ControlBase(element, options) {
                        _super.call(this);
                        var p = this.properties;
                        p.element = element;
                        p.options = options;
                    }
                    ControlBase.prototype.update = function (options) {
                        this.properties.options = options;
                        // will be overwritten in deriving class
                    };

                    ControlBase.prototype.$initialize = function () {
                        var controlType = SDL.Client.Type.resolveNamespace(this.getTypeName());
                        this.properties.element[Controls.getInstanceAttributeName(controlType)] = this;
                        Core.Renderers.ControlRenderer.onControlCreated(this);
                    };

                    ControlBase.prototype.render = function (callback, errorcallback) {
                        this.setRendered(callback);
                        // override in subclasses
                    };

                    ControlBase.prototype.setRendered = function (callback) {
                        if (callback) {
                            callback();
                        }
                    };

                    ControlBase.prototype.getElement = function () {
                        return this.properties.element;
                    };

                    ControlBase.prototype.dispose = function () {
                        this.callBase("SDL.Client.Types.ObjectWithEvents", "dispose");
                        Core.Renderers.ControlRenderer.onControlDisposed(this);
                    };
                    return ControlBase;
                })(SDL.Client.Types.ObjectWithEvents);
                Controls.ControlBase = ControlBase;

                ControlBase.prototype.disposeInterface = SDL.Client.Types.OO.nonInheritable(function SDL$UI$Core$Controls$ControlBase$disposeInterface() {
                });

                SDL.Client.Types.OO.createInterface("SDL.UI.Core.Controls.ControlBase", ControlBase);
            })(Core.Controls || (Core.Controls = {}));
            var Controls = Core.Controls;
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
//# sourceMappingURL=ControlBase.js.map
/// <reference path="../../SDL.Client.Core/Libraries/jQuery/jQuery.d.ts" />
/// <reference path="../Renderers/ControlRenderer.ts" />
/// <reference path="Base.ts" />
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            (function (Controls) {
                function createJQueryPlugin(jQuery, control, name, methods) {
                    jQuery.fn[name] = function SDL$UI$Core$ControlBase$widget(options) {
                        var instances = [];
                        var jQueryObject = this;

                        jQueryObject.each(function () {
                            var element = this;
                            var attrName = Controls.getInstanceAttributeName(control);
                            var instance = element[attrName];
                            if (!instance || (instance.getDisposed && instance.getDisposed())) {
                                // create a control instance
                                instance = element[attrName] = new control(element, options);
                                instance.render();
                            } else if (options && instance.update) {
                                // Call update on the existing instance
                                instance.update(options);
                            }
                            instances.push(instance);
                        });

                        jQueryObject = jQueryObject.pushStack(instances);

                        if (methods) {
                            jQuery.each(methods, function (i, methodDefinition) {
                                if (methodDefinition && methodDefinition.method && methodDefinition.method != "dispose") {
                                    jQueryObject[methodDefinition.method] = function () {
                                        var implementation = methodDefinition.implementation || methodDefinition.method;
                                        for (var i = 0, len = this.length; i < len; i++) {
                                            var instance = jQueryObject[i];
                                            var result = instance[implementation].apply(instance, arguments);
                                            if (methodDefinition.returnsValue) {
                                                return result;
                                            }
                                        }
                                        return jQueryObject;
                                    };
                                }
                            });
                        }

                        jQueryObject["dispose"] = function () {
                            for (var i = 0, len = this.length; i < len; i++) {
                                SDL.UI.Core.Renderers.ControlRenderer.disposeControl(jQueryObject[i]);
                            }
                            return jQueryObject.end();
                        };

                        return jQueryObject;
                    };
                }
                Controls.createJQueryPlugin = createJQueryPlugin;
            })(Core.Controls || (Core.Controls = {}));
            var Controls = Core.Controls;
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
//# sourceMappingURL=jQuery.js.map
/// <reference path="ControlBase.ts" />
/// <reference path="../Event/Constants.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            (function (Controls) {
                eval(SDL.Client.Types.OO.enableCustomInheritance);
                var FocusableControlBase = (function (_super) {
                    __extends(FocusableControlBase, _super);
                    function FocusableControlBase() {
                        _super.apply(this, arguments);
                    }
                    FocusableControlBase.prototype.$initialize = function () {
                        this.callBase("SDL.UI.Core.Controls.ControlBase", "$initialize");

                        this.properties.$element = SDL.jQuery(this.properties.element);
                    };

                    FocusableControlBase.prototype.handleFocusOut = function () {
                        // override this method in the deriving class
                    };

                    FocusableControlBase.prototype.startCaptureFocus = function (triggerOnResize, triggerOnScroll) {
                        if (typeof triggerOnResize === "undefined") { triggerOnResize = false; }
                        var p = this.properties;
                        if (!p.capturingFocus) {
                            p.capturingFocus = true;

                            p.initialTabIndex = p.$element.attr("tabIndex") || null;
                            if (!p.initialTabIndex) {
                                p.$element.attr("tabIndex", "0"); // make element 'focusable'
                            }

                            window.addEventListener("mousedown", this.getDelegate(this.onMouseDown), true);
                            SDL.jQuery(window).on("focusin", this.getDelegate(this.onWindowFocusIn)); // detect when focus leaves an element in the window
                            SDL.jQuery(window).on("focusout", this.getDelegate(this.onWindowFocusOut)); // detect when focus goes to an element in the window
                        }

                        if (triggerOnResize && !p.handlingResize) {
                            p.handlingResize = true;
                            window.addEventListener("resize", this.getDelegate(this.onResize));
                        }

                        if (triggerOnScroll && !p.handlingScrollElement) {
                            p.handlingScrollElement = triggerOnScroll;
                            window.addEventListener("scroll", this.getDelegate(this.onScroll), true);
                        }

                        p.isPausedCaptureFocus = false;

                        this.stopWindowFocusOut();
                        this.checkFocusedElement(function () {
                            return p.$element.focus();
                        });
                    };

                    FocusableControlBase.prototype.stopCaptureFocus = function () {
                        var p = this.properties;
                        if (p.capturingFocus) {
                            p.capturingFocus = false;
                            window.removeEventListener("mousedown", this.getDelegate(this.onMouseDown), true);

                            if (p.handlingResize) {
                                p.handlingResize = false;
                                window.removeEventListener("resize", this.getDelegate(this.onResize));
                            }

                            if (p.handlingScrollElement) {
                                p.handlingScrollElement = null;
                                window.removeEventListener("scroll", this.getDelegate(this.onScroll), true);
                            }

                            this.cancelCheckFocusedElementAfterDelay();

                            p.isWindowFocusOut = false;
                            SDL.jQuery(window).off("focusin", this.getDelegate(this.onWindowFocusIn));
                            SDL.jQuery(window).off("focusout", this.getDelegate(this.onWindowFocusOut));

                            this.cancelCheckFocusedElementAfterDelay();

                            if (p.initialTabIndex) {
                                p.$element.attr("tabIndex", p.initialTabIndex);
                            } else {
                                p.$element.removeAttr("tabIndex");
                            }
                        }
                    };

                    FocusableControlBase.prototype.pauseCaptureFocus = function () {
                        this.properties.isPausedCaptureFocus = true;
                    };

                    FocusableControlBase.prototype.checkFocusedElement = function (focusOutHandler) {
                        var p = this.properties;

                        this.cancelCheckFocusedElementAfterDelay();

                        if (p.capturingFocus && !p.isPausedCaptureFocus) {
                            if (p.element.contains(document.activeElement)) {
                                // focus is inside the element
                                if (p.isWindowFocusOut) {
                                    // when focus goes into an iframe, there's no event triggered when the iframe loses the focus (Chrome and FF)
                                    // -> monitor it with timeout
                                    this.checkFocusedElementAfterDelay(500);
                                }
                            } else if (p.isWindowFocusOut && (!document.activeElement || document.activeElement == document.body)) {
                                // focus is not in the window
                                // focus will not be fired if click in an iframe inside the window
                                // -> monitor it with timeout
                                this.checkFocusedElementAfterDelay(500);
                            } else {
                                focusOutHandler ? focusOutHandler() : this.handleFocusOut();
                            }
                        }
                    };

                    FocusableControlBase.prototype.onMouseDown = function (e) {
                        if (!this.properties.element.contains(e.target)) {
                            this.handleFocusOut();
                        }
                    };

                    FocusableControlBase.prototype.onWindowFocusOut = function (e) {
                        var p = this.properties;
                        if (p.capturingFocus && !p.isPausedCaptureFocus) {
                            p.isWindowFocusOut = true;

                            if (!e || !e.relatedTarget) {
                                this.checkFocusedElementAfterDelay();
                            } else if (!p.element.contains(e.relatedTarget)) {
                                this.handleFocusOut();
                            } else {
                                // focusin will not be fired if click in an iframe inside the window
                                // -> monitor it with timeout
                                this.checkFocusedElementAfterDelay(500);
                            }
                        }
                    };

                    FocusableControlBase.prototype.onWindowFocusIn = function () {
                        this.stopWindowFocusOut();
                        this.checkFocusedElementAfterDelay();
                    };

                    FocusableControlBase.prototype.stopWindowFocusOut = function () {
                        this.properties.isWindowFocusOut = false;
                    };

                    FocusableControlBase.prototype.checkFocusedElementAfterDelay = function (delay) {
                        var p = this.properties;
                        if (p.capturingFocus && !p.isPausedCaptureFocus) {
                            if (!p.checkFocusedElementTimeout) {
                                p.checkFocusedElementTimeout = window.setTimeout(this.checkFocusedElement.bind(this), delay);
                            } else if (!delay) {
                                window.clearTimeout(p.checkFocusedElementTimeout);
                                p.checkFocusedElementTimeout = window.setTimeout(this.checkFocusedElement.bind(this), delay);
                            }
                        }
                    };

                    FocusableControlBase.prototype.cancelCheckFocusedElementAfterDelay = function () {
                        var p = this.properties;
                        if (p.checkFocusedElementTimeout) {
                            window.clearTimeout(p.checkFocusedElementTimeout);
                            p.checkFocusedElementTimeout = null;
                        }
                    };

                    FocusableControlBase.prototype.onScroll = function (e) {
                        var p = this.properties;
                        if (!p.isPausedCaptureFocus && (e.target == p.handlingScrollElement || e.target.contains(p.handlingScrollElement))) {
                            // trigger focusout if scrolling is not inside the element
                            this.handleFocusOut();
                        }
                    };

                    FocusableControlBase.prototype.onResize = function (e) {
                        if (!this.properties.isPausedCaptureFocus) {
                            this.handleFocusOut();
                        }
                    };
                    return FocusableControlBase;
                })(Controls.ControlBase);
                Controls.FocusableControlBase = FocusableControlBase;

                FocusableControlBase.prototype.disposeInterface = SDL.Client.Types.OO.nonInheritable(function SDL$UI$Controls$FocusableControlBase$disposeInterface() {
                    this.stopCaptureFocus();
                });

                SDL.Client.Types.OO.createInterface("SDL.UI.Core.Controls.FocusableControlBase", FocusableControlBase);
            })(Core.Controls || (Core.Controls = {}));
            var Controls = Core.Controls;
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
//# sourceMappingURL=FocusableControlBase.js.map
/*! @namespace {SDL.UI.Core.Css} */
SDL.Client.Type.registerNamespace("SDL.UI.Core.Css");

SDL.UI.Core.Css.addDomClasses = function SDL$UI$Core$Css$addDomClasses(doc)
{
	var $documentElement = SDL.jQuery(doc.documentElement);
	if (SDL.jQuery.browser.msie)
	{
		$documentElement.addClass("ie");
	}
	else if (SDL.jQuery.browser.mozilla)
	{
		$documentElement.addClass("gecko");
	}
	else if (SDL.jQuery.browser.webkit)
	{
		$documentElement.addClass("webkit");
	}
};

SDL.UI.Core.Css.addDomClasses(document);
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            (function (Css) {
                (function (ZIndexManager) {
                    ZIndexManager.baseZIndex = 100;

                    var rootElement = {
                        element: document.body,
                        zIndex: -1,
                        parent: null,
                        zIndexedElements: []
                    };

                    var allZIndexedElements = [];

                    function setNextZIndex(element, bringToFront) {
                        if (typeof bringToFront === "undefined") { bringToFront = false; }
                        // find closest z-indexed ancestor element
                        var closestParentElement = rootElement;
                        var parentElement = findParentZIndexedElement(element, rootElement.zIndexedElements) || (rootElement.topmostElements && findParentZIndexedElement(element, rootElement.topmostElements));
                        while (parentElement) {
                            closestParentElement = parentElement;
                            parentElement = findParentZIndexedElement(element, parentElement.zIndexedElements) || (parentElement.topmostElements && findParentZIndexedElement(element, parentElement.topmostElements));
                        }

                        var entry;
                        var parentZIndexedElements;
                        var parentTopmostElements;

                        if (closestParentElement.element == element) {
                            var index;
                            var i;

                            entry = closestParentElement;
                            parentZIndexedElements = entry.parent.zIndexedElements;
                            parentTopmostElements = entry.parent.topmostElements;

                            if (entry.isTopmost) {
                                index = parentTopmostElements.indexOf(entry);
                                if (bringToFront) {
                                    // topmost -> topmost
                                    if (index != parentTopmostElements.length - 1) {
                                        moveZIndexes(entry.zIndex, getMaximalZIndex(entry, true), getMaximalZIndex(entry.parent, true));
                                        for (i = index + 1; i < parentTopmostElements.length; i++) {
                                            parentTopmostElements[i - 1] = parentTopmostElements[i];
                                        }
                                        parentTopmostElements[parentTopmostElements.length - 1] = entry;
                                    }
                                } else {
                                    // topmost -> ordinary zIndexed
                                    moveZIndexes(entry.zIndex, getMaximalZIndex(entry, true), getMaximalZIndex(entry.parent, false));
                                    entry.isTopmost = false;
                                    parentTopmostElements.splice(index, 1);
                                    parentZIndexedElements.push(entry);
                                }
                            } else {
                                index = parentZIndexedElements.indexOf(entry);
                                if (bringToFront) {
                                    // ordinary zIndexed -> topmost
                                    moveZIndexes(entry.zIndex, getMaximalZIndex(entry, true), getMaximalZIndex(entry.parent, true));
                                    entry.isTopmost = true;
                                    parentZIndexedElements.splice(index, 1);
                                    if (!parentTopmostElements) {
                                        entry.parent.topmostElements = [entry];
                                    } else {
                                        parentTopmostElements.push(entry);
                                    }
                                } else {
                                    // ordinary zIndexed -> ordinary zIndexed
                                    if (index != parentZIndexedElements.length - 1) {
                                        moveZIndexes(entry.zIndex, getMaximalZIndex(entry, true), getMaximalZIndex(entry.parent, false));
                                        for (i = index + 1; i < parentZIndexedElements.length; i++) {
                                            parentZIndexedElements[i - 1] = parentZIndexedElements[i];
                                        }
                                        parentTopmostElements[parentZIndexedElements.length - 1] = entry;
                                    }
                                }
                            }
                        } else {
                            // element might be z-indexed with insertZIndexBefore -> release it first
                            releaseZIndex(element);

                            entry = registerZIndexedElement(element, closestParentElement, getMaximalZIndex(closestParentElement, bringToFront), bringToFront);

                            if (bringToFront) {
                                if (!closestParentElement.topmostElements) {
                                    closestParentElement.topmostElements = [entry];
                                } else {
                                    closestParentElement.topmostElements.push(entry);
                                }
                            } else {
                                // show the target as the topmost z-indexed element within the parent
                                closestParentElement.zIndexedElements.push(entry);
                            }
                        }
                    }
                    ZIndexManager.setNextZIndex = setNextZIndex;

                    function getZIndex(element) {
                        for (var i = allZIndexedElements.length - 1; i >= 0; i--) {
                            if (allZIndexedElements[i].element == element) {
                                return allZIndexedElements[i].zIndex + ZIndexManager.baseZIndex;
                            }
                        }
                    }
                    ZIndexManager.getZIndex = getZIndex;

                    function insertZIndexBefore(element, beforeElement) {
                        if (element && beforeElement && element != beforeElement) {
                            for (var i = allZIndexedElements.length - 1; i >= 0; i--) {
                                if (allZIndexedElements[i].element == beforeElement) {
                                    var beforeZIndexedElement = allZIndexedElements[i];

                                    for (var j = allZIndexedElements.length - 1; j >= 0; j--) {
                                        if (allZIndexedElements[j].element == element) {
                                            // element is already z-indexed
                                            var prevZIndexedElement = allZIndexedElements[j];
                                            if (prevZIndexedElement.parent) {
                                                if (prevZIndexedElement.parent != beforeZIndexedElement.parent) {
                                                    throw Error("insertZIndexBefore: can't set z-index before another element from a different z-index parent");
                                                }

                                                throw Error("insertZIndexBefore: changing z-index for elements that are already z-indexed is not implemented yet.");
                                            } else {
                                                // element has no parent, good, just reorder
                                                moveZIndexes(prevZIndexedElement.zIndex, prevZIndexedElement.zIndex, beforeZIndexedElement.zIndex - 1);
                                            }
                                            return;
                                        }
                                    }

                                    //element is not z-indexed yet
                                    registerZIndexedElement(element, null, beforeZIndexedElement.zIndex - 1);
                                    return;
                                }
                            }
                        }
                    }
                    ZIndexManager.insertZIndexBefore = insertZIndexBefore;

                    function releaseZIndex(element) {
                        for (var i = allZIndexedElements.length - 1; i >= 0; i--) {
                            if (allZIndexedElements[i].element == element) {
                                var entry = allZIndexedElements[i];
                                var parent = entry.parent;

                                if (parent) {
                                    var index = parent.zIndexedElements.indexOf(entry);

                                    if (index != -1) {
                                        parent.zIndexedElements.splice(parent.zIndexedElements.indexOf(entry), 1);
                                    } else if (parent.topmostElements) {
                                        index = parent.topmostElements.indexOf(entry);
                                        if (index != -1) {
                                            parent.topmostElements.splice(parent.topmostElements.indexOf(entry), 1);
                                        }
                                    }
                                }

                                removeZIndexes(i, getMaximalZIndex(entry, true));
                                return;
                            }
                        }
                    }
                    ZIndexManager.releaseZIndex = releaseZIndex;

                    function findParentZIndexedElement(element, zIndexedElements) {
                        for (var i = zIndexedElements.length - 1; i >= 0; i--) {
                            if (zIndexedElements[i].element.contains(element)) {
                                return zIndexedElements[i];
                            }
                        }
                    }

                    function getMaximalZIndex(zIndexedElement, checkTopmostElements) {
                        if (checkTopmostElements && zIndexedElement.topmostElements && zIndexedElement.topmostElements.length) {
                            return getMaximalZIndex(zIndexedElement.topmostElements[zIndexedElement.topmostElements.length - 1], true);
                        } else if (zIndexedElement.zIndexedElements.length) {
                            return getMaximalZIndex(zIndexedElement.zIndexedElements[zIndexedElement.zIndexedElements.length - 1], checkTopmostElements);
                        } else {
                            return zIndexedElement.zIndex;
                        }
                    }

                    function registerZIndexedElement(element, parent, afterZIndex, isTopmost) {
                        if (typeof isTopmost === "undefined") { isTopmost = false; }
                        var entry = {
                            element: element,
                            zIndex: afterZIndex + 1,
                            isTopmost: isTopmost,
                            parent: parent,
                            zIndexedElements: [],
                            topmostElements: null
                        };

                        setAfterZIndex(entry, afterZIndex);
                        return entry;
                    }

                    function setAfterZIndex(entry, afterZIndex) {
                        var zIndex = afterZIndex + 1;
                        for (var i = allZIndexedElements.length; i > zIndex; i--) {
                            var moveEntry = allZIndexedElements[i - 1];
                            allZIndexedElements[i] = moveEntry;
                            moveEntry.element.style.zIndex = (++moveEntry.zIndex + ZIndexManager.baseZIndex).toString();
                        }
                        allZIndexedElements[zIndex] = entry;
                        entry.element.style.zIndex = ((entry.zIndex = zIndex) + ZIndexManager.baseZIndex).toString();
                    }

                    function removeZIndexes(zIndexStart, zIndexEnd) {
                        var zIndexCount = zIndexEnd - zIndexStart + 1;
                        for (var i = zIndexEnd + 1; i < allZIndexedElements.length; i++) {
                            var moveEntry = allZIndexedElements[i];
                            allZIndexedElements[i - zIndexCount] = moveEntry;
                            moveEntry.element.style.zIndex = ((moveEntry.zIndex -= zIndexCount) + ZIndexManager.baseZIndex).toString();
                        }
                        allZIndexedElements.splice(allZIndexedElements.length - zIndexCount, zIndexCount);
                    }

                    function moveZIndexes(zIndexStart, zIndexEnd, afterZIndex) {
                        if (zIndexStart > afterZIndex) {
                            moveZIndexes(afterZIndex + 1, zIndexStart - 1, zIndexEnd);
                        } else {
                            var distance = afterZIndex - zIndexEnd;
                            if (distance > 0) {
                                var zIndexCount = zIndexEnd - zIndexStart + 1;
                                if (zIndexCount) {
                                    for (var i = zIndexStart; i <= zIndexEnd; i++) {
                                        allZIndexedElements[i].element.style.zIndex = ((allZIndexedElements[i].zIndex = i + distance) + ZIndexManager.baseZIndex).toString();
                                    }

                                    for (i = zIndexEnd + 1; i <= afterZIndex; i++) {
                                        allZIndexedElements[i].element.style.zIndex = ((allZIndexedElements[i].zIndex = i - zIndexCount) + ZIndexManager.baseZIndex).toString();
                                    }

                                    allZIndexedElements.splice.bind(allZIndexedElements, zIndexStart, 0).apply(null, allZIndexedElements.splice(zIndexEnd + 1, distance));
                                }
                            }
                        }
                    }
                })(Css.ZIndexManager || (Css.ZIndexManager = {}));
                var ZIndexManager = Css.ZIndexManager;
            })(Core.Css || (Core.Css = {}));
            var Css = Core.Css;
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
//# sourceMappingURL=ZIndexManager.js.map
input:not(type).invalid,
input[type="text"].invalid,
input[type="password"].invalid,
input[type="email"].invalid,
input[type="url"].invalid {
  border-color: #e04a32;
  background-color: rgba(224, 74, 50, 0.2);
}
/*! @namespace {SDL.UI.Core.Event.Constants} */
SDL.Client.Type.registerNamespace("SDL.UI.Core.Event.Constants");

/**
 * Defines the ASCII key codes for some common keys.
 * @enum
 */
SDL.UI.Core.Event.Constants.Keys =
{
	BACKSPACE: 8,
	ALT: 18,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGEDOWN: 34,
	PAGEUP: 33,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38,

	A: 65,
	C: 67,
	V: 86,
	X: 88,

	F1: 112,
	F2: 113,
	F3: 114,
	F4: 115,
	F5: 116,
	F6: 117,
	F7: 118,
	F8: 119,
	F9: 120,
	F10: 121,
	F11: 122,
	F12: 123
};
/// <reference path="../../SDL.Client.Core/Libraries/jQuery/SDL.jQuery.d.ts" />
/// <reference path="../../SDL.Client.Core/Types/Types.d.ts" />
/// <reference path="../../SDL.Client.Core/Types/Array.d.ts" />
/// <reference path="../../SDL.Client.Core/Types/OO.d.ts" />
/// <reference path="../../SDL.Client.Core/Diagnostics/Assert.d.ts" />
/// <reference path="../../SDL.Client.Core/Resources/ResourceManager.d.ts" />
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            (function (Renderers) {
                ;

                var ViewRenderer = (function () {
                    function ViewRenderer() {
                    }
                    ViewRenderer.registerTemplateRenderer = function (type, renderer) {
                        ViewRenderer.templateRenderers[type] = renderer;
                    };

                    ViewRenderer.getTemplateRenderer = function (type) {
                        return ViewRenderer.templateRenderers[type];
                    };

                    ViewRenderer.renderView = function (type, element, settings, callback, errorcallback) {
                        if (element) {
                            SDL.jQuery(element).data("view-create", true);
                        }

                        SDL.Client.Resources.ResourceManager.load(type, function () {
                            if (!element || SDL.jQuery(element).data("view-create")) {
                                var ctor = ViewRenderer.types[type];
                                if (!ctor) {
                                    ctor = ViewRenderer.types[type] = ViewRenderer.getTypeConstructor(type);
                                }

                                if (!element) {
                                    if (ctor.createElement) {
                                        element = ctor.createElement(document, settings);
                                    } else {
                                        element = document.createElement("div");
                                    }
                                }

                                // Instantiate the view
                                var view = new ctor(element, settings);
                                if (!SDL.Client.Types.OO.implementsInterface(view, "SDL.UI.Core.Views.ViewBase")) {
                                    SDL.Client.Diagnostics.Assert.raiseError("'" + type + "' must implement SDL.UI.Core.Views.ViewBase interface.");
                                }

                                // Render the view
                                view.render(!callback ? null : function () {
                                    callback(view);
                                });
                            }
                        }, errorcallback);
                    };

                    ViewRenderer.onViewCreated = function (view) {
                        var type = view.getTypeName();
                        if (ViewRenderer.createdViews[type]) {
                            ViewRenderer.createdViews[type].push(view);
                        } else {
                            ViewRenderer.createdViews[type] = [view];
                        }
                    };

                    ViewRenderer.disposeView = function (view) {
                        SDL.jQuery(view.getElement()).removeData();
                        view.dispose();
                    };

                    ViewRenderer.onViewDisposed = function (view) {
                        var type = view.getTypeName();
                        if (ViewRenderer.createdViews[type]) {
                            SDL.Client.Types.Array.removeAt(ViewRenderer.createdViews[type], ViewRenderer.createdViews[type].indexOf(view));
                        }
                    };

                    ViewRenderer.getCreatedViewCounts = function () {
                        var createdViews = {};
                        SDL.jQuery.each(ViewRenderer.createdViews, function (type, views) {
                            createdViews[type] = views.length;
                        });
                        return createdViews;
                    };

                    ViewRenderer.getTypeConstructor = function (type) {
                        SDL.Client.Diagnostics.Assert.isString(type, "View type name is expected.");

                        var ctor;
                        try  {
                            ctor = SDL.Client.Type.resolveNamespace(type);
                        } catch (err) {
                            SDL.Client.Diagnostics.Assert.raiseError("Unable to evaluate \"" + type + "\": " + err.description);
                        }
                        SDL.Client.Diagnostics.Assert.isFunction(ctor, "Unable to evaluate \"" + type + "\".");
                        return ctor;
                    };
                    ViewRenderer.templateRenderers = {};
                    ViewRenderer.types = {};
                    ViewRenderer.createdViews = {};
                    return ViewRenderer;
                })();
                Renderers.ViewRenderer = ViewRenderer;
                ;
            })(Core.Renderers || (Core.Renderers = {}));
            var Renderers = Core.Renderers;
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
;
//# sourceMappingURL=ViewRenderer.js.map
/*! @namespace {SDL.UI.Core.Utils.Dom} */
(function($)
{
	$.fn.parentWindow = function()
	{
		// assuming all elements are in the same window
		var elem = this[0];
		win = elem && elem.ownerDocument && (elem.ownerDocument.defaultView || elem.ownerDocument.parentWindow);
		return win ? $(win) : $();
	};

	$.fn.enableSelection = function()
	{
		return this.attr('unselectable', 'off')
				.css('user-select', 'text')
				.css('-webkit-user-select', 'text')
				.css('-moz-user-select', 'text')
				.css('-ms-user-select', 'text')
				.off("selectstart");
	};

	$.fn.disableSelection = function()
	{
		return this.attr('unselectable', 'on')
			.css('user-select', 'none')
			.css('-webkit-user-select', 'none')
			.css('-moz-user-select', '-moz-none')
			.css('-ms-user-select', 'none')
			.on("selectstart", function(e) { return $(e.target).is("input:text"); });
	};

	$.fn.unwrapInner = function()
	{
		$.each(this, function(index, element)
			{
				var child = element.firstChild;
				if (child)
				{
					while (child.firstChild)
					{
						element.insertBefore(child.firstChild, child);
					}
					element.removeChild(child);
				}
			});
		return this;
	};

	$.uniqueId = function SDL$Client$Types$Object$uniqueId()
	{
		return SDL.Client.Types.Object.getUniqueId(this[0]);
	};

})(SDL.jQuery);/*! @namespace {SDL.UI.Core.Utils.Event} */
SDL.Client.Type.registerNamespace("SDL.UI.Core.Utils.Event");

/**
 * Returns <c>true</c> if the current event was raised by a left mouse click.
 * @param {DOMEvent} e The event that was raised.
 * @return {Boolean} A value indicating whether the current event was raised by a left mouse click.
 */
SDL.UI.Core.Utils.Event.isLeftButton = function SDL$UI$Core$Utils$Event$isLeftButton(e)
{
	return e && (SDL.jQuery.browser.msie ? (e.button == 1 || e.type == "click") : e.button == 0) || false;
};

/**
 * Returns <c>true</c> if the event has Ctrl key set.
 * @param {DOMEvent} e The event.
 */
SDL.UI.Core.Utils.Event.ctrlKey = function SDL$UI$Core$Utils$Event$ctrlKey(e)
{
	return e && (SDL.jQuery.browser.macintosh ? (e.metaKey && !e.ctrlKey) : e.ctrlKey) || false;
};/*! normalize.css v2.1.0 | MIT License | git.io/normalize */
/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */
/**
 * Correct `block` display not defined in IE 8/9.
 */
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
  display: block;
}
/**
 * Correct `inline-block` display not defined in IE 8/9.
 */
audio,
canvas,
video {
  display: inline-block;
}
/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */
audio:not([controls]) {
  display: none;
  height: 0;
}
/**
 * Address styling not present in IE 8/9.
 */
[hidden] {
  display: none;
}
/* ==========================================================================
   Base
   ========================================================================== */
/**
 * 1. Set default font family to sans-serif.
 * 2. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */
html {
  font-family: sans-serif;
  /* 1 */
  -webkit-text-size-adjust: 100%;
  /* 2 */
  -ms-text-size-adjust: 100%;
  /* 2 */
}
/**
 * Remove default margin.
 */
body {
  margin: 0;
}
/* ==========================================================================
   Links
   ========================================================================== */
/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */
a:focus {
  outline: thin dotted;
}
/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */
a:active,
a:hover {
  outline: 0;
}
/* ==========================================================================
   Typography
   ========================================================================== */
/**
 * Address variable `h1` font-size and margin within `section` and `article`
 * contexts in Firefox 4+, Safari 5, and Chrome.
 */
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
/**
 * Address styling not present in IE 8/9, Safari 5, and Chrome.
 */
abbr[title] {
  border-bottom: 1px dotted;
}
/**
 * Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome.
 */
b,
strong {
  font-weight: bold;
}
/**
 * Address styling not present in Safari 5 and Chrome.
 */
dfn {
  font-style: italic;
}
/**
 * Address differences between Firefox and other browsers.
 */
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}
/**
 * Address styling not present in IE 8/9.
 */
mark {
  background: #ff0;
  color: #000;
}
/**
 * Correct font family set oddly in Safari 5 and Chrome.
 */
code,
kbd,
pre,
samp {
  font-family: monospace, serif;
  font-size: 1em;
}
/**
 * Improve readability of pre-formatted text in all browsers.
 */
pre {
  white-space: pre-wrap;
}
/**
 * Set consistent quote types.
 */
q {
  quotes: "\201C" "\201D" "\2018" "\2019";
}
/**
 * Address inconsistent and variable font size in all browsers.
 */
small {
  font-size: 80%;
}
/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sup {
  top: -0.5em;
}
sub {
  bottom: -0.25em;
}
/* ==========================================================================
   Embedded content
   ========================================================================== */
/**
 * Remove border when inside `a` element in IE 8/9.
 */
img {
  border: 0;
}
/**
 * Correct overflow displayed oddly in IE 9.
 */
svg:not(:root) {
  overflow: hidden;
}
/* ==========================================================================
   Figures
   ========================================================================== */
/**
 * Address margin not present in IE 8/9 and Safari 5.
 */
figure {
  margin: 0;
}
/* ==========================================================================
   Forms
   ========================================================================== */
/**
 * Define consistent border, margin, and padding.
 */
fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}
/**
 * 1. Correct `color` not being inherited in IE 8/9.
 * 2. Remove padding so people aren't caught out if they zero out fieldsets.
 */
legend {
  border: 0;
  /* 1 */
  padding: 0;
  /* 2 */
}
/**
 * 1. Correct font family not being inherited in all browsers.
 * 2. Correct font size not being inherited in all browsers.
 * 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome.
 */
button,
input,
select,
textarea {
  font-family: inherit;
  /* 1 */
  font-size: 100%;
  /* 2 */
  margin: 0;
  /* 3 */
}
/**
 * Address Firefox 4+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */
button,
input {
  line-height: normal;
}
/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */
button,
select {
  text-transform: none;
}
/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 */
button,
html input[type="button"],
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button;
  /* 2 */
  cursor: pointer;
  /* 3 */
}
/**
 * Re-set default cursor for disabled elements.
 */
button[disabled],
html input[disabled] {
  cursor: default;
}
/**
 * 1. Address box sizing set to `content-box` in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 */
input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box;
  /* 1 */
  padding: 0;
  /* 2 */
}
/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */
input[type="search"] {
  -webkit-appearance: textfield;
  /* 1 */
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box;
  /* 2 */
  box-sizing: content-box;
}
/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
/**
 * Remove inner padding and border in Firefox 4+.
 */
button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
/**
 * 1. Remove default vertical scrollbar in IE 8/9.
 * 2. Improve readability and alignment in all browsers.
 */
textarea {
  overflow: auto;
  /* 1 */
  vertical-align: top;
  /* 2 */
}
/* ==========================================================================
   Tables
   ========================================================================== */
/**
 * Remove most spacing between table cells.
 */
table {
  border-collapse: collapse;
  border-spacing: 0;
}
/**
    Correct default cursor behaviour across the site
    relies on body having cursor: default below.
*/
* {
  cursor: inherit;
}
html,
body,
#main-view-target {
  height: 100%;
  width: 100%;
  margin: 0;
  padding: 0;
  border: none;
  cursor: default;
}
input,
textarea {
  cursor: auto;
}
input[type="button"],
button {
  cursor: pointer;
}
body {
  font-family: Arial, sans-serif;
  font-size: 12px;
}
h1 {
  font-size: 26px;
  margin: 0;
  margin-bottom: 20px;
}
h2 {
  font-size: 20px;
  margin: 0;
}
h3 {
  font-size: 16px;
  margin: 0;
}
h4 {
  font-size: 12px;
  margin: 0;
}
h5 {
  font-size: 8px;
  margin: 0;
}
.overflow-ellipsis {
  overflow: hidden;
  -ms-text-overflow: ellipsis;
  -o-text-overflow: ellipsis;
  text-overflow: ellipsis;
}
/*! @namespace {SDL.UI.Core.Views.ViewBase} */
SDL.Client.Types.OO.createInterface("SDL.UI.Core.Views.ViewBase");

/**
* Provides the base class for all tridion controls.
* @constructor
* @param {HTMLElement} markupElement The html element that contains the declarative markup for this control.
*/
SDL.UI.Core.Views.ViewBase.$constructor = function SDL$UI$Core$View$ViewBase$constructor(element, settings)
{
    this.addInterface("SDL.Client.Types.ObjectWithEvents");

    var p = this.properties;
	p.element = element;
	p.settings = settings;
};

SDL.UI.Core.Views.ViewBase.prototype.$initialize = function SDL$UI$Core$View$ViewBase$initialize()
{
	SDL.UI.Core.Renderers.ViewRenderer.onViewCreated(this);
	this.properties.templateName = this.getTypeName();
};

SDL.UI.Core.Views.ViewBase.prototype.getRenderOptions = function SDL$UI$Core$View$ViewBase$getRenderOptions()
{
	return null;
};

SDL.UI.Core.Views.ViewBase.prototype.render = function SDL$UI$Core$View$ViewBase$render(callback)
{
	this.getTemplateRenderer().render(this.getTemplateData(), this.properties.element, this.getRenderOptions(), callback);
};

SDL.UI.Core.Views.ViewBase.prototype.getTemplateData = function SDL$UI$Core$View$ViewBase$getTemplateData()
{
	var templateResource = this.getTemplateResource();
	if (!templateResource || !templateResource.loaded)
	{
		throw Error("Template resource '" + this.getTemplateName() + "' is not loaded.");
	}
	return templateResource.template;
};

SDL.UI.Core.Views.ViewBase.prototype.getTemplateResource = function SDL$UI$Core$View$ViewBase$getTemplateResource()
{
	return SDL.Client.Resources.ResourceManager.getTemplateResource(this.getTemplateName());
};

SDL.UI.Core.Views.ViewBase.prototype.getTemplateRenderer = function SDL$UI$Core$View$ViewBase$getTemplateRenderer()
{
	var templateName = this.getTemplateName();
	var templateResource = SDL.Client.Resources.ResourceManager.getTemplateResource(templateName);
	if (!templateResource || !templateResource.loaded)
	{
		throw Error("Template resource '" + templateName + "' is not loaded.");
	}
	var renderer = SDL.UI.Core.Renderers.ViewRenderer.getTemplateRenderer(templateResource.type);
	if (!renderer)
	{
		throw Error("No renderer is registered for tempalte type '" + templateResource.type + "' (tempalte '" + templateName + "'). ");
	}
	return renderer;
};

SDL.UI.Core.Views.ViewBase.prototype.getTemplateName = function SDL$UI$Core$View$ViewBase$getTemplateName()
{
    return this.properties.templateName;
}

SDL.UI.Core.Views.ViewBase.prototype.getElement = function SDL$UI$Core$View$ViewBase$getElement()
{
    return this.properties.element;
}

SDL.UI.Core.Views.ViewBase.prototype.disposeInterface = SDL.Client.Types.OO.nonInheritable(function SDL$UI$Core$View$ViewBase$disposeInterface()
{
	SDL.UI.Core.Renderers.ViewRenderer.onViewDisposed(this);
});/// <reference path="../../SDL.Client.Core/Libraries/jQuery/SDL.jQuery.d.ts" />
/// <reference path="../../SDL.Client.Core/ConfigurationManager/ConfigurationManager.d.ts" />
/// <reference path="../../SDL.Client.Core/Resources/ResourceManager.d.ts" />
/// <reference path="../../SDL.Client.Core/Event/EventRegister.d.ts" />
/// <reference path="../Renderers/ViewRenderer.ts" />
/// <reference path="../Renderers/ControlRenderer.ts" />
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            var cm = SDL.Client.Configuration.ConfigurationManager;
            var rm = SDL.Client.Resources.ResourceManager;

            var pageNode = cm.getCurrentPageConfigurationNode();
            if (pageNode) {
                var view = pageNode.getAttribute("view");
                if (view) {
                    rm.load("SDL.UI.Core.Renderers.ViewRenderer", function () {
                        var target = document.getElementById("main-view-target") || document.body;
                        Core.Renderers.ViewRenderer.renderView(view, target, null, function (view) {
                            SDL.Client.Event.EventRegister.addEventHandler(SDL.Client.Event.EventRegister, "beforedispose", function () {
                                Core.Renderers.ViewRenderer.disposeView(view);
                            });
                        });

                        SDL.Client.Event.EventRegister.addEventListener("dispose", function () {
                            var undisposed = [];
                            SDL.jQuery.each(Core.Renderers.ViewRenderer.getCreatedViewCounts(), function (i, value) {
                                if (value != 0) {
                                    undisposed.push(i + " (" + value + ")");
                                }
                            });

                            if (Core.Renderers.ControlRenderer != null) {
                                SDL.jQuery.each(Core.Renderers.ControlRenderer.getCreatedControlCounts(), function (i, value) {
                                    if (value != 0) {
                                        undisposed.push(i + " (" + value + ")");
                                    }
                                });
                            }

                            if (undisposed.length) {
                                alert("Some views/controls have been left undisposed:\n" + undisposed.join("\n"));
                            }
                        });
                    });
                    rm.load(view); // this is to start loading view's resources while ViewRenderer is being loaded
                }
            }
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
//# sourceMappingURL=init.js.map
/// <reference path="../../SDL.Client.Core/Application/Application.d.ts" />
/// <reference path="../../SDL.Client.Core/Event/EventRegister.d.ts" />
/// <reference path="../../SDL.Client.Core/Libraries/jQuery/SDL.jQuery.d.ts" />
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Core) {
            (function (Event) {
                (function (GlobalMouseEventTracker) {
                    if (SDL.Client) {
                        var Application = SDL.Client.Application;
                        if (Application) {
                            Application.addInitializeCallback(function () {
                                if (Application.isHosted && Application.ApplicationHost.isSupported("startCaptureDomEvents")) {
                                    document.addEventListener("mousedown", function () {
                                        Application.ApplicationHost.startCaptureDomEvents(["mouseup", "mousemove"]);
                                    });

                                    document.addEventListener("mouseup", function () {
                                        Application.ApplicationHost.stopCaptureDomEvents();
                                    });

                                    Application.ApplicationHost.addEventListener("domevent", function (e) {
                                        if (e.data.type == "mouseup") {
                                            SDL.Client.Application.ApplicationHost.stopCaptureDomEvents();
                                        }

                                        if (SDL.jQuery) {
                                            SDL.jQuery(document).trigger(e.data);
                                        }

                                        if (SDL.Client.Event) {
                                            var EventRegister = SDL.Client.Event.EventRegister;
                                            if (EventRegister) {
                                                EventRegister.handleEvent(document, e.data);
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    }
                })(Event.GlobalMouseEventTracker || (Event.GlobalMouseEventTracker = {}));
                var GlobalMouseEventTracker = Event.GlobalMouseEventTracker;
            })(Core.Event || (Core.Event = {}));
            var Event = Core.Event;
        })(UI.Core || (UI.Core = {}));
        var Core = UI.Core;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
//# sourceMappingURL=GlobalMouseEventTracker.js.map
/*
 * classList.js: Cross-browser full element.classList implementation.
 * 2014-07-23
 *
 * By Eli Grey, http://eligrey.com
 * Public Domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/

if ("document" in self) {

// Full polyfill for browsers with no classList support
if (!("classList" in document.createElement("_"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
	  classListProp = "classList"
	, protoProp = "prototype"
	, elemCtrProto = view.Element[protoProp]
	, objCtr = Object
	, strTrim = String[protoProp].trim || function () {
		return this.replace(/^\s+|\s+$/g, "");
	}
	, arrIndexOf = Array[protoProp].indexOf || function (item) {
		var
			  i = 0
			, len = this.length
		;
		for (; i < len; i++) {
			if (i in this && this[i] === item) {
				return i;
			}
		}
		return -1;
	}
	// Vendors: please allow content code to instantiate DOMExceptions
	, DOMEx = function (type, message) {
		this.name = type;
		this.code = DOMException[type];
		this.message = message;
	}
	, checkTokenAndGetIndex = function (classList, token) {
		if (token === "") {
			throw new DOMEx(
				  "SYNTAX_ERR"
				, "An invalid or illegal string was specified"
			);
		}
		if (/\s/.test(token)) {
			throw new DOMEx(
				  "INVALID_CHARACTER_ERR"
				, "String contains an invalid character"
			);
		}
		return arrIndexOf.call(classList, token);
	}
	, ClassList = function (elem) {
		var
			  trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
			, classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
			, i = 0
			, len = classes.length
		;
		for (; i < len; i++) {
			this.push(classes[i]);
		}
		this._updateClassName = function () {
			elem.setAttribute("class", this.toString());
		};
	}
	, classListProto = ClassList[protoProp] = []
	, classListGetter = function () {
		return new ClassList(this);
	}
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
	return this[i] || null;
};
classListProto.contains = function (token) {
	token += "";
	return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
	;
	do {
		token = tokens[i] + "";
		if (checkTokenAndGetIndex(this, token) === -1) {
			this.push(token);
			updated = true;
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.remove = function () {
	var
		  tokens = arguments
		, i = 0
		, l = tokens.length
		, token
		, updated = false
		, index
	;
	do {
		token = tokens[i] + "";
		index = checkTokenAndGetIndex(this, token);
		while (index !== -1) {
			this.splice(index, 1);
			updated = true;
			index = checkTokenAndGetIndex(this, token);
		}
	}
	while (++i < l);

	if (updated) {
		this._updateClassName();
	}
};
classListProto.toggle = function (token, force) {
	token += "";

	var
		  result = this.contains(token)
		, method = result ?
			force !== true && "remove"
		:
			force !== false && "add"
	;

	if (method) {
		this[method](token);
	}

	if (force === true || force === false) {
		return force;
	} else {
		return !result;
	}
};
classListProto.toString = function () {
	return this.join(" ");
};

if (objCtr.defineProperty) {
	var classListPropDesc = {
		  get: classListGetter
		, enumerable: true
		, configurable: true
	};
	try {
		objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	} catch (ex) { // IE 8 doesn't support enumerable:true
		if (ex.number === -0x7FF5EC54) {
			classListPropDesc.enumerable = false;
			objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
		}
	}
} else if (objCtr[protoProp].__defineGetter__) {
	elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
	"use strict";

	var testElement = document.createElement("_");

	testElement.classList.add("c1", "c2");

	// Polyfill for IE 10/11 and Firefox <26, where classList.add and
	// classList.remove exist but support only one argument at a time.
	if (!testElement.classList.contains("c2")) {
		var createMethod = function(method) {
			var original = DOMTokenList.prototype[method];

			DOMTokenList.prototype[method] = function(token) {
				var i, len = arguments.length;

				for (i = 0; i < len; i++) {
					token = arguments[i];
					original.call(this, token);
				}
			};
		};
		createMethod('add');
		createMethod('remove');
	}

	testElement.classList.toggle("c3", false);

	// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
	// support the second argument.
	if (testElement.classList.contains("c3")) {
		var _toggle = DOMTokenList.prototype.toggle;

		DOMTokenList.prototype.toggle = function(token, force) {
			if (1 in arguments && !this.contains(token) === !force) {
				return force;
			} else {
				return _toggle.call(this, token);
			}
		};

	}

	testElement = null;
}());

}

}
/* 
 * The MIT License
 *
 * Copyright (c) 2014 Tony Leeper
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function () {
    function getContentElementFromInput(input) {
        return input.parentElement.getElementsByTagName('placeholder-shim-content')[0];
    }

    function updatePlaceholderText(input, placeholderText) {
        var content = getContentElementFromInput(input);
        content.childNodes[0].nodeValue = placeholderText;
    }

    function applyPlaceholderShim(input) {
        var placeholderText = input.getAttribute('placeholder');
        if (placeholderText === null || typeof placeholderText === 'undefined') {
            if (input.placeholderShimIsBound) {
                updatePlaceholderText(input, '');
            }
            return;
        }

        if (input.placeholderShimIsBound) {
            updatePlaceholderText(input, placeholderText);
            input.placeholderShim_setPlaceholderVisibility();
            return;
        }

        var currentStyle = window.getComputedStyle(input);
        var paddingTop = currentStyle.paddingTop;
        var paddingRight = currentStyle.paddingRight;
        var paddingBottom = currentStyle.paddingBottom;
        var paddingLeft = currentStyle.paddingLeft;
        var shim = document.createElement('placeholder-shim');
        var content = document.createElement('placeholder-shim-content');
        var text = document.createTextNode(placeholderText);
        content.appendChild(text);
        shim.appendChild(content);
        shim.setAttribute('style', 'display: inline-block; position: relative; cursor: text');
        var height = input.getBoundingClientRect().height;
        var rightOffset = 2 + parseInt(paddingRight, 10);
        content.setAttribute('style',
            'position: absolute;  color: #a0a0a0; padding-top: ' + paddingTop + '; padding-right: ' + paddingRight +
            '; padding-bottom: ' + paddingBottom + '; padding-left: ' + paddingLeft + '; top: 0; left: 2px; right: ' +
            rightOffset + 'px; overflow: hidden;  cursor: text; height: ' + height + 'px; line-height: ' + height + 'px');
        wrap(input, shim);

        input.placeholderShim_hidePlaceholder = function () {
            content.style.display = 'none';
        };
        input.addEventListener('focus', input.placeholderShim_hidePlaceholder);

        input.placeholderShim_setPlaceholderVisibility = function () {
            if (document.activeElement !== input && input.value === '') {
                content.style.display = 'inline-block';
            } else {
                content.style.display = 'none';
            }
        };
        input.addEventListener('blur', input.placeholderShim_setPlaceholderVisibility);

        input.placeholderShim_onMouseDownHandler = function (e) {
            input.focus();
            e.preventDefault();
        };
        content.addEventListener('mousedown', input.placeholderShim_onMouseDownHandler);

        // set initial visibility in case the input already has a value
        input.placeholderShim_setPlaceholderVisibility();

        input.placeholderShimIsBound = true;
    }

    function destroy(input) {
        input.removeEventListener('focus', input.placeholderShim_hidePlaceholder);
        input.removeEventListener('blur', input.placeholderShim_setPlaceholderVisibility);
        var content = getContentElementFromInput(input);
        content.removeEventListener('mousedown', input.placeholderShim_onMouseDownHandler);

        input.setPlaceholderVisibility = null;
        input.placeholderShimVisibilityInterval = null;
        input.placeholderShimIsBound = null;
    }

    function wrap(elms, withElement) {
        // Convert `elms` to an array, if necessary.
        if (!elms.length) elms = [elms];

        // Loops backwards to prevent having to clone the wrapper on the
        // first element (see `child` below).
        for (var i = elms.length - 1; i >= 0; i--) {
            var child = (i > 0) ? withElement.cloneNode(true) : withElement;
            var el = elms[i];

            // Cache the current parent and sibling.
            var parent = el.parentNode;
            var sibling = el.nextSibling;

            // Wrap the element (is automatically removed from its current
            // parent).
            child.appendChild(el);

            // If the element had a sibling, insert the wrapper before
            // the sibling to maintain the HTML structure; otherwise, just
            // append it to the parent.
            if (sibling) {
                parent.insertBefore(child, sibling);
            } else {
                parent.appendChild(child);
            }
        }
    }

    function nativePlaceHolderSupport() {
        var test = document.createElement('input');
        return ('placeholder' in test);
    }

    function hasOrIsDescendant(node, descendant) {
        if (node === descendant) {
            return true;
        }

        for (var i = 0; i < node.children.length; i++) {
            if (hasOrIsDescendant(node.children[i], descendant)) {
                return true;
            }
        }

        return false;
    }

    function checkForInputDisposal(e) {
        var inputs = document.getElementsByTagName('input');
        Array.prototype.forEach.call(inputs, function (input) {
            if (input.placeholderShimIsBound && hasOrIsDescendant(e.srcElement, input)) {
                destroy(input);
            }
        });
    }

    function init() {
        if (!nativePlaceHolderSupport()) {
            var busy;
            var inputs = document.getElementsByTagName('input');
            for (var i = 0; i < inputs.length; i++) {
                applyPlaceholderShim(inputs[i]);
            }
            setInterval(function () {
                if (busy) {
                    return;
                }
                busy = true;
                inputs = document.getElementsByTagName('input');
                for (var i = 0; i < inputs.length; i++) {
                    applyPlaceholderShim(inputs[i]);
                }
                busy = false;
            }, 100);

            document.addEventListener('DOMNodeRemoved', checkForInputDisposal);
        }
    }

    init();
}());