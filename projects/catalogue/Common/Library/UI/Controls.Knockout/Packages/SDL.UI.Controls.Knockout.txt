/*278,310,266,270,266,270,294,266,286,270,282,1612,6480,21628,186,278,119,123,274,286,290,7678,117*//// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/ActionBar/ActionBar.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.ActionBar, "SDL.UI.Controls.Knockout.ActionBar");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/ActivityIndicator/ActivityIndicator.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.ActivityIndicator, "SDL.UI.Controls.Knockout.ActivityIndicator");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/Button/Button.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.Button, "SDL.UI.Controls.Knockout.Button");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/Callout/Callout.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.Callout, "SDL.UI.Controls.Knockout.Callout");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/Dialog/Dialog.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.Dialog, "SDL.UI.Controls.Knockout.Dialog");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/Message/Message.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.Message, "SDL.UI.Controls.Knockout.Message");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/ResizeTrigger/ResizeTrigger.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.ResizeTrigger, "SDL.UI.Controls.Knockout.ResizeTrigger");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/TopBar/TopBar.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.TopBar, "SDL.UI.Controls.Knockout.TopBar");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/TopPageTabs/TopPageTabs.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.TopPageTabs, "SDL.UI.Controls.Knockout.TopPageTabs");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/Tooltip/Tooltip.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.Tooltip, "SDL.UI.Controls.Knockout.Tooltip");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/ScrollView/ScrollView.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.ScrollView, "SDL.UI.Controls.Knockout.ScrollView");
.line-graph svg .data-point {
  stroke: #0066df;
  stroke-width: 2px;
  fill: #ffffff;
}
.line-graph svg .data-point:hover {
  stroke-width: 3px;
}
.line-graph svg path {
  fill: none;
  stroke: #0066df;
  stroke-width: 2px;
}
.line-graph svg .x-axis path,
.line-graph svg .x-axis line {
  fill: none;
  stroke: #878787;
  stroke-width: 1px;
  shape-rendering: crispEdges;
}
.line-graph svg .x-axis.with-negatives path {
  stroke: none;
}
.line-graph svg .x-axis-zeroline path,
.line-graph svg .x-axis-zeroline line {
  fill: none;
  stroke: #878787;
  stroke-width: 1px;
  shape-rendering: crispEdges;
}
.line-graph svg .y-axis path,
.line-graph svg .y-axis line {
  fill: none;
  stroke: #dddddd;
  stroke-width: 1px;
  shape-rendering: crispEdges;
}
.line-graph svg .axis text {
  font-size: 9px;
  word-spacing: -1px;
  fill: #878787;
  shape-rendering: crispEdges;
}
.line-graph svg .y-axis-gridlines path,
.line-graph svg .y-axis-gridlines line {
  stroke: #dddddd;
  stroke-width: 1px;
  shape-rendering: crispEdges;
}
.line-graph svg .goal-line {
  stroke: #0066df;
  stroke-width: 2px;
  shape-rendering: crispEdges;
  opacity: 0.5;
}
.line-graph svg .goal-line.lower {
  opacity: 0.25;
}
.line-graph svg .goal-shading {
  fill: #dddddd;
  stroke-width: 0;
  shape-rendering: crispEdges;
  opacity: 0.5;
}
.line-graph svg .goal-shading.lower {
  opacity: 0.5;
}
.line-graph svg .intersection {
  fill: transparent;
  stroke: transparent;
  stroke-width: 3px;
  opacity: 0.5;
}
.line-graph svg .intersection:hover {
  stroke: #0066df;
  fill: #ffffff;
}
.line-graph svg rect.weekend {
  fill: #fafafa;
}
var app =
{
	constants:
	{
		date:
		{
			MILLISECONDS_IN_DAY: 1000*60*60*24
		}
	},

	locale:
	{
		localize: function(res)
		{
			switch (res)
			{
				case "":
					return;
				case "":
					return;
				case "CampaignMetrics.Goal":
					return "Goal";
				case "CampaignMetrics.GoalReached":
					return "Goal line crossed at";
				case "CampaignMetrics.Today":
					return "today";
				default:
					return res;
			}
		},

		format: function (value, format)
		{
			return SDL.Globalize.format(value, format);
		},

		formatDecimal: function(number)
		{
			if (typeof number !== 'string')
			{
				number = number.toString();
			}

			var digitsAfterDecimal = number.split(".")[1];
			var globalizeNumberModifier = 'n';
			if (digitsAfterDecimal)
			{
				globalizeNumberModifier += digitsAfterDecimal.length;
			}
			else
			{
				globalizeNumberModifier += '0';
			}

			return this.format(parseFloat(number), globalizeNumberModifier);
		}
	},

	utils:
	{
		/**
			returns the number of days between two dates
			@param {date} date1 The first date
			@param {date} date2 The second date
		*/
		daysBetween: function(date1, date2)
		{
			return Math.round(Math.abs((date1.getTime() - date2.getTime()) / app.constants.date.MILLISECONDS_IN_DAY));
		},

		/**
			Returns true if the value is null or undefined, otherwise returns false
			@param {object} value The value to test
			@return {boolean} true if value is null or undefined, otherwise false
		*/
		isNullOrUndefined: function (value)
		{
			return value === null || typeof (value) === "undefined";
		},

		number:
		{
			/**
				defines a set of multipliers for SI unit conversion
			*/
			multipliers: [
				{ value: 1e24, suffix: 'Y' },
				{ value: 1e21, suffix: 'Z' },
				{ value: 1e18, suffix: 'E' },
				{ value: 1e15, suffix: 'P' },
				{ value: 1e12, suffix: 'T' },
				{ value: 1e9, suffix: 'G' },
				{ value: 1e6, suffix: 'M' },
				{ value: 1e3, suffix: 'k' },
				{ value: 1e0, suffix: '' },
				{ value: 1e-3, suffix: 'm' },
				{ value: 1e-6, suffix: 'Âµ' },
				{ value: 1e-9, suffix: 'n' },
				{ value: 1e-12, suffix: 'p' },
				{ value: 1e-15, suffix: 'f' },
				{ value: 1e-18, suffix: 'a' },
				{ value: 1e-21, suffix: 'z' },
				{ value: 1e-24, suffix: 'y' }
			],
			/**
				converts a number to a short form using SI units using decimal place precision instead of number of digits
				@param {number} number the number to convert
				@param {number} decimalPlaces the number of decimal places to display
				@param {object} multiplier optional multiplier to use, otherwise calculated
			*/
			convertToSIUnitsUsingDecimalPlacePrecision: function (number, decimalPlaces, multiplier)
			{
				if (number < 0)
				{
					return '-' + app.utils.number.convertToSIUnitsUsingDecimalPlacePrecision(-number, decimalPlaces, multiplier);
				}

				if (number === 0)
				{
					return number;
				}

				if (app.utils.isNullOrUndefined(decimalPlaces))
				{
					decimalPlaces = 1;
				}

				if (app.utils.isNullOrUndefined(multiplier))
				{
					multiplier = this.getSIMultiplierFor(number);
				}

				// TFS: 26307 - don't use the milli "m" SI unit
				if (multiplier.suffix === "m")
				{
					multiplier = { value: 1, suffix: '' };
					//decimalPlaces = 3;
				}
				if (!app.utils.isNullOrUndefined(multiplier))
				{
					return app.locale.format((number / multiplier.value), 'n' + decimalPlaces) + multiplier.suffix;
				}

				return number.toExponential();
			},

			/**
				converts a number to a short form using SI units
				@param {number} number the number to convert
				@param {number} significantDigits the number of significant digits to display
				@param {object} multiplier optional multiplier to use, otherwise calculated
			*/
			convertToSIUnits: function(number, significantDigits, multiplier)
			{
				if (number < 0)
				{
					return '-' + app.utils.number.convertToSIUnits(-number, significantDigits, multiplier);
				}

				if (number === 0)
				{
					return number;
				}

				if (app.utils.isNullOrUndefined(significantDigits))
				{
					significantDigits = 3;
				}

				if (app.utils.isNullOrUndefined(multiplier))
				{
					multiplier = this.getSIMultiplierFor(number);
				}

				if (!app.utils.isNullOrUndefined(multiplier))
				{
					// TFS: 26307 - don't use the milli "m" SI unit
					if (multiplier.suffix === "m")
					{
						// resort to decimal place precision with 3dp
						return app.utils.number.convertToSIUnitsUsingDecimalPlacePrecision(number, 3, { value: 1, suffix: '' });
					}

					//globalize doesn't support significant digits, so we have to work it out in terms of decimal places ourselves
					var sigDigitRepresentation = (number / multiplier.value).toPrecision(significantDigits);
					var localizedResult = app.locale.formatDecimal(sigDigitRepresentation);

					return localizedResult + multiplier.suffix;
				}

				return number.toExponential();
			},

			/**
				gets the SI unit to use for this number
				@param {number} number The number to get the SI multiplier for
			*/
			getSIMultiplierFor: function(number)
			{
				if (number < 1e27 && number > 1e-27)
				{
					for (var i = 0; i < this.multipliers.length; i++)
					{
						if (number >= this.multipliers[i].value)
						{
							return this.multipliers[i];
						}
					}
				}

				return null;
			}
		}
	}
};

if (typeof Date.prototype.addDays !== "function") {
    /**
        returns a new date, adding a specified number of days to the date
        @param {number} days The number of days to add to the date
    */
    Date.prototype.addDays = function (days) {
        var dat = new Date(this.valueOf());
        dat.setDate(dat.getDate() + days);
        return dat;
    };
}

if (typeof Date.prototype.isToday !== "function") {
    /**
        returns true if the date is today, otherwise false
        @param {date} date the date to check
    */
    Date.prototype.isToday = function () {
        var today = new Date();
        return today.getDate() === this.getDate() &&
            today.getMonth() === this.getMonth() &&
            today.getYear() === this.getYear();
    };
}

if (typeof Math.log10 !== "function") {
    Math.log10 = function (value) {
        return Math.log(value) / Math.LN10;
    };
}/**
    Custom binding for displaying a line graph
    Usage: data-bind="lineGraph: { data: data, width: width, height: height, padding: padding, paddingTop: paddingTop, paddingRight: paddingRight, paddingBottom: paddingBottom, paddingLeft: paddingLeft, animationSpeed: animationSpeed }"
*/
ko.bindingHandlers.lineGraph = {
    getXAxisDefinition: function (dataset) {
        // we want the x-axis to have nicely spaced out days, so we'll take the earliest and latest date in the dataset and interpolate the tick points
        var minX = new Date(new Date(d3.min(dataset, function (d) { return d.date; })));
        var maxX = new Date(new Date(d3.max(dataset, function (d) { return d.date; })));
        maxX = maxX.addDays(1);

        // strip off the hours, minutes and seconds for the day step calculation
        minX.setHours(0, 0, 0, 0);
        maxX.setHours(0, 0, 0, 0);

        // we want nicely spaced out tick values
        var dayStep;
        var daysBetween = app.utils.daysBetween(minX, maxX);
        dayStep = Math.ceil(daysBetween / 8);

        // create an array to hold the tick values
        var xAxisTickValues = [];
        var xAxisTickValue = minX.addDays(dayStep);
        while (xAxisTickValue < maxX) {
            xAxisTickValues.push(xAxisTickValue);
            xAxisTickValue = xAxisTickValue.addDays(dayStep);
        }
        maxX = xAxisTickValue;
        xAxisTickValues.push(maxX);

        return {
            min: minX,
            max: maxX,
            ticks: xAxisTickValues,
            tickDayStep: dayStep
        };
    },

    init: function (element, valueAccessor) {

        var binding = ko.unwrap(valueAccessor());

        // get the data
        var dataset = ko.unwrap(binding.data);
        if (app.utils.isNullOrUndefined(dataset) || dataset.length === 0) {
            return;
        }

        var goalLine = ko.unwrap(binding.goalLine);
        
        // get the animation speed
        element.animationSpeed = ko.unwrap(binding.animationSpeed) || 1000;

        // Define the resolution
        var width = ko.unwrap(binding.width) || 600;
        var height = ko.unwrap(binding.height) || 300;
        
        // Define the padding around the graph
        var padding = ko.unwrap(binding.padding) || 50;
        var paddingTop = ko.unwrap(binding.paddingTop) || padding;
        var paddingRight = ko.unwrap(binding.paddingRight) || padding;
        var paddingBottom = ko.unwrap(binding.paddingBottom) || padding;
        var paddingLeft = ko.unwrap(binding.paddingLeft) || padding;
        
        // Create the SVG 'canvas'
        var svg = d3.select(element)
            .append("svg")
            .attr("width", width + "px")
            .attr("height", height + "px");

        // Set the scales
        var xAxisDefinition = ko.bindingHandlers.lineGraph.getXAxisDefinition(dataset);
        element.xScale = d3.time.scale()
            .domain([xAxisDefinition.min, xAxisDefinition.max])
            .range([paddingLeft, width - paddingRight]);

        var yAxisMin = d3.min(dataset, function (d) { return d.value(); });
        var yAxisMax = d3.max(dataset, function (d) { return d.value(); });

        if (goalLine) {
            var goalLineMax = d3.max(goalLine, function(goal) { return goal.Value; } );
            yAxisMax = goalLineMax > yAxisMax ? goalLineMax : yAxisMax;

            //null date values in goal lines mean "forever" so set them to the edges of the x axis
            for (var i = 0; i < goalLine.length; i++ ) {
                if (app.utils.isNullOrUndefined(goalLine[i].startDate)) {
                    goalLine[i].startDate = xAxisDefinition.min;
                }
                if (app.utils.isNullOrUndefined(goalLine[i].endDate)) {
                    goalLine[i].endDate = xAxisDefinition.max;
                }
            }
        }

        var datasetHasNegatives = yAxisMin < 0;

        if (yAxisMin === 0 && yAxisMax === 0) { // if all zero, then default to 0 to 1 axis
            yAxisMax = 1;
        }

        var datasetIsAllNegative = yAxisMin < 0 && yAxisMax < 0;
        if (datasetIsAllNegative) { // push the axis up to zero if all negatives
            yAxisMax = 0;
            
            // temporary workaround for d3 not calculating the axis correctly when negatives are used, TODO: investigate further if this is a d3 bug or some missunderstanding
            dataset.push({ date: null, value: ko.observable(0) });
        }

        if (yAxisMin > 0) { // bring the axis down to zero if all positives
            yAxisMin = 0;
        }

        element.yScale = d3.scale.linear()
            .domain([yAxisMin, yAxisMax])
            .range([height - paddingTop, paddingBottom]);

        // draw the goal line if set
        var newGoals;
        if (goalLine) {
            newGoals = svg.selectAll(".goal-line")
                .data(goalLine)
                .enter();

            newGoals.append("rect")
                .attr("class", function(d, j) {
                    //need to check whether there is a goal line above this one
                    for (var i = 0; i < goalLine.length; i++) {
                        if (i !== j && d.Value < goalLine[i].Value) {
                            if (( goalLine[i].startDate <= d.startDate && goalLine[i].endDate >= d.startDate )
                                || ( goalLine[i].startDate <= d.endDate && goalLine[i].endDate >= d.endDate )) {

                                return "goal-shading lower";
                            }
                        }
                    }
                    return "goal-shading";
                });
        }

        // set rough # of ticks on y-axis (D3 makes a judgement still based on the data)
        var yAxisTicks = 7;

        // y-axis gridlines
        element.yAxisGridlines = d3.svg.axis()
            .scale(element.yScale)
            .orient("left")
            .tickFormat("")
            .tickSize(-width + paddingLeft + paddingRight, 0, 0)
            .ticks(yAxisTicks);

        svg.append("g")
            .attr("class", "axis y-axis-gridlines")
            .attr("transform", "translate(" + paddingLeft + ", 0)")
            .call(element.yAxisGridlines);

        // x-axis gridlines
        element.xAxisGridlines = d3.svg.axis()
            .scale(element.xScale)
            .orient("bottom")
            .tickFormat("")
            .tickValues(xAxisDefinition.ticks.map(function (d) { return d; }))
            .tickSize(-height + paddingTop + paddingBottom, 0, 0);

        svg.append("g")
            .attr("class", "axis y-axis-gridlines")
            .attr("transform", "translate(0," + (height - paddingTop) + ")")
            .call(element.xAxisGridlines);

        // y-axis
        var decimalPlacesOnYAxis = 1 + Math.ceil(Math.max(0, -Math.log10(Math.abs(yAxisMax - yAxisMin))));
        element.yAxis = d3.svg.axis()
            .scale(element.yScale)
            .orient("left")
            .tickFormat(function (d) { return app.utils.number.convertToSIUnitsUsingDecimalPlacePrecision(d, decimalPlacesOnYAxis, app.utils.number.getSIMultiplierFor(Math.max(Math.abs(yAxisMax), Math.abs(yAxisMin)))); }.bind(this))
            .tickSize(5, 5, 0)
            .ticks(yAxisTicks);

        svg.append("g")
            .attr("class", "axis y-axis")
            .attr("transform", "translate(" + paddingLeft + ",0)")
            .call(element.yAxis);

        // x-axis
        var xAxisTickLength = 3; // px
        if (datasetHasNegatives) {
            element.xAxis = d3.svg.axis()
                .scale(element.xScale)
                .orient("bottom")
                .tickFormat(function (d) { return app.locale.format(d, "MMM d").toUpperCase(); })
                .tickValues(xAxisDefinition.ticks.map(function (d) { return d; }))
                .tickSize(xAxisTickLength, xAxisTickLength, 0);

            svg.append("g")
                .attr("class", "axis x-axis with-negatives")
                .attr("transform", "translate(0, " + (height - paddingTop) + ")")
                .call(element.xAxis);

            element.xAxisZeroLine = d3.svg.axis()
                .scale(element.xScale)
                .orient("bottom")
                .tickFormat("")
                .tickValues(xAxisDefinition.ticks.map(function (d) { return d; }))
                .tickSize(xAxisTickLength, xAxisTickLength, 0);

            svg.append("g")
                .attr("class", "axis x-axis-zeroline")
                .attr("transform", "translate(0, " + element.yScale(0) + ")")
                .call(element.xAxisZeroLine);
        } else {
            element.xAxis = d3.svg.axis()
                .scale(element.xScale)
                .orient("bottom")
                .tickFormat(function (d) { return app.locale.format(d, "MMM d").toUpperCase(); })
                .tickValues(xAxisDefinition.ticks.map(function (d) { return d; }))
                .tickSize(xAxisTickLength, xAxisTickLength, 0);

            svg.append("g")
                .attr("class", "axis x-axis")
                .attr("transform", "translate(0, " + element.yScale(0) + ")")
                .call(element.xAxis);
        }

        // tweak the x-axis ticks so that they cross the line
        svg.selectAll(".x-axis").selectAll(".tick").selectAll("line")
            .attr("y1", -xAxisTickLength);
        svg.selectAll(".x-axis-zeroline").selectAll(".tick").selectAll("line")
            .attr("y1", -xAxisTickLength);

        if (datasetIsAllNegative) {
            // see above: temporary workaround for d3 not calculating the axis correctly when negatives are used, TODO: investigate further if this is a d3 bug or some missunderstanding
            dataset.pop();
        }

        //draw the goal line after the grid so that is appears on top of grid lines
        if (newGoals) {
            newGoals.append("line")
                .attr("class", function(d, j) {
                    for (var i = 0; i < goalLine.length; i++) {
                        if (i !== j && d.Value < goalLine[i].Value) {
                            if (( goalLine[i].startDate <= d.startDate && goalLine[i].endDate >= d.startDate )
                                || ( goalLine[i].startDate <= d.endDate && goalLine[i].endDate >= d.endDate )) {

                                return "goal-line lower";
                            }
                        }
                    }
                    return "goal-line";
                });
        }

        // draw line graph
        element.line = d3.svg.line()
            .x(function (d) {
                return element.xScale(d.date);
            })
            .y(function (d) {
                return element.yScale(d.value());
            });

        svg.append("svg:path")
            .attr("class", "line-graph")
            .attr("d", element.line(dataset));

        // plot circles
        var circles = svg.selectAll("circle")
            .data(dataset);

        circles.enter()
            .append("circle")
            .attr("class", "data-point")
            .attr("cx", function (d) {
                return element.xScale(d.date);
            })
            .attr("cy", function (d) {
                return element.yScale(d.value());
            })
            .attr("r", 4)
            .attr("data-bind", (function(goalData) {
                return function (d) {
                    var goalInformation = "";
                    //figure out if the data point coincides with a goal
                    for (var i = 0; i < goalData.length; i++) {
                        if (d.date <= goalData[i].endDate && d.date >= goalData[i].startDate) {
                            goalInformation += "<div><span>" +
                                                    app.locale.localize("CampaignMetrics.Goal") +
                                                ": </span><strong>" +
                                                    app.utils.number.convertToSIUnits(goalData[i].Value) +
                                                "</strong></div>";
                        }
                    }
                    return "tooltip: { content: '" + app.locale.format(d.date, "dddd, MMMM d, yyyy HH:mm") + ": <strong>" + app.utils.number.convertToSIUnits(d.value()) + "</strong>" + goalInformation + "'}";
                };
            })(goalLine));
            
    },

    update: function (element, valueAccessor) {

        var binding = ko.unwrap(valueAccessor());

        // get the data
        var dataset = ko.unwrap(binding.data);
        if (app.utils.isNullOrUndefined(dataset) || dataset.length === 0) {
            return;
        }

        var goalLine = ko.unwrap(binding.goalLine);
        var svg = d3.select(element).select("svg");
        var xAxisDefinition = ko.bindingHandlers.lineGraph.getXAxisDefinition(dataset);
        // update the scales
        /*
            TODO: removed temporarily because of an issue with all negatives showing no scale;
            we're not using animations on this graph at the moment, need to investigate different animations, and fix the scales
        var xAxisDefinition = ko.bindingHandlers.lineGraph.getXAxisDefinition(dataset);
        element.xScale.domain([xAxisDefinition.min, xAxisDefinition.max]);

        var yAxisMin = d3.min(dataset, function (d) { return Math.min(d.value(), 0); });
        var yAxisMax = goalLine ? d3.max(dataset, function(d) { return Math.max(d.value(), goalLine); }) : d3.max(dataset, function(d) { return d.value(); });
        if (yAxisMin === 0 && yAxisMax === 0) {
            yAxisMax = 1;
        }
        element.yScale.domain([yAxisMin, yAxisMax]);
        */

        // update the goal line if set
        if (goalLine) {

            svg.selectAll(".goal-shading")
                .data(goalLine)
                .sort(function(a, b) { return b.Value - a.Value; })
                .transition()
                .duration(element.animationSpeed)
                .attr("x", function (goal) {
                    if (goal.startDate < xAxisDefinition.min) {
                        return element.xScale(xAxisDefinition.min);
                    }
                    return element.xScale(goal.startDate);
                })
                .attr("y", function (goal) {
                    return element.yScale(goal.Value);
                })
                .attr("width", function (goal) {
                    var start = goal.startDate,
                        end = goal.endDate;
                    if (goal.startDate < xAxisDefinition.min) {
                        start = xAxisDefinition.min;
                    }

                    if (goal.endDate > xAxisDefinition.max) {
                        end = xAxisDefinition.max;
                    }
                    return element.xScale(end) - element.xScale(start);
                })
                .attr("height", function (goal) {
                    return element.yScale(0) - element.yScale(goal.Value);
                });

            svg.selectAll(".goal-line")
                .data(goalLine)
                .transition()
                .duration(element.animationSpeed)
                .attr("x1", function (goal) {
                    if (goal.startDate < xAxisDefinition.min) {
                        return element.xScale(xAxisDefinition.min);
                    }
                    return element.xScale(goal.startDate);
                })
                .attr("y1", function (goal) {
                    return element.yScale(goal.Value);
                })
                .attr("x2", function (goal) {
                    if (goal.endDate > xAxisDefinition.max) {
                        return element.xScale(xAxisDefinition.max);
                    }
                    return element.xScale(goal.endDate);
                })
                .attr("y2", function (goal) {
                    return element.yScale(goal.Value);
                });

            //if the line crosses a goal, interpolate the point on the x axis that they crossed
            var intersectionPoints = [];
            for (var i = 1; i < dataset.length; i++) {
                for (var j = 0; j < goalLine.length; j++) {
                    //test if line intersection is possible with each goal line
                    if (dataset[i-1].date <= goalLine[j].endDate && dataset[i-1].date >= goalLine[j].startDate ||
                        dataset[i].date <= goalLine[j].endDate && dataset[i].date >= goalLine[j].startDate) {

                        //determine if an intersection occurs. See http://en.wikipedia.org/wiki/Line-line_intersection for info on the calculation
                        var x1 = element.xScale(dataset[i].date);
                        var y1 = element.yScale(dataset[i].value());
                        var x2 = element.xScale(dataset[i - 1].date);
                        var y2 = element.yScale(dataset[i - 1].value());
                        var x3 = element.xScale(goalLine[j].startDate);
                        var y3 = element.yScale(goalLine[j].Value);
                        var x4 = element.xScale(goalLine[j].endDate);
                        var y4 = y3;    //goal lines are always fixed (horizontal) on the y scale

                        //get the coordinates of the intersection
                        var xIntersection = ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4)) / ((x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4));
                        var yIntersection = ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4)) / ((x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4));

                        //check that the intersection point is on both line segments
                        if (xIntersection >= x1 && xIntersection <= x2 && xIntersection >= x3 && xIntersection <= x4 &&
                            (yIntersection >= y1 && yIntersection <= y2 || yIntersection <= y1 && yIntersection >= y2)) {

                            //we have an intersection point!
                            intersectionPoints.push({
                                intersectionX: xIntersection,
                                intersectionY: yIntersection
                            });
                        }
                    }
                }
            }

            //add a point with tooltip at each intersection point
            var intersections = svg.selectAll(".intersection")
                .data(intersectionPoints);

            intersections.enter().append("circle")
                .attr("class", "intersection")
                .attr("cx", function (d) {
                    return d.intersectionX;
                })
                .attr("cy", function (d) {
                    return d.intersectionY;
                })
                .attr("r", 4)
                .attr("data-bind", function (d) {
                        var intersectionDate = element.xScale.invert(d.intersectionX);
                        return "tooltip: { content: '" + app.locale.localize("CampaignMetrics.GoalReached") + ": <strong>" + app.locale.format(intersectionDate, "dddd, MMMM d, yyyy HH:mm") + "</strong>'}";
                    });
            

        }

        // update line graph
        svg.selectAll(".line-graph")
            .data(dataset)
            .transition()
            .duration(element.animationSpeed)
            .attr("d", element.line(dataset));

        // update circles
        svg.selectAll("circle")
            .data(dataset)
            .transition()
            .duration(element.animationSpeed)
            .attr("cx", function (d) {
                return element.xScale(d.date);
            })
            .attr("cy", function (d) {
                return element.yScale(d.value());
            });

        // update the x-axis
        svg.select(".x-axis")
            .transition()
            .duration(element.animationSpeed)
            .call(element.xAxis);
        
        // tweak the x-axis labels so that they have more spacing from the axis
        var xAxisLabelMargin = 12; // px
        svg.selectAll(".x-axis").selectAll(".tick").selectAll("text")
            .attr("dy", xAxisLabelMargin + "px");

        // add in the text "(today)" to the x-axis labels if it matches today's date
        var xAxisTicks = svg.selectAll(".x-axis").selectAll(".tick");
        xAxisTicks.each(function(d) {
            if (d.isToday()) {
                d3.select(this).append("svg:text")
                    .attr("y", "12")
                    .attr("x", "0")
                    .attr("dy", "18px")
                    .style("text-anchor", "middle")
                    .text("(" + app.locale.localize("CampaignMetrics.Today") + ")");
            }
        });
        
        // update the y-axis gridlines
        svg.select(".y-axis-gridlines")
            .transition()
            .duration(element.animationSpeed)
            .call(element.yAxisGridlines);

        // update the y-axis
        svg.select(".y-axis")
            .transition()
            .duration(element.animationSpeed)
            .call(element.yAxis);
    }
};/// <reference path="../../SDL.Client.UI.Core.Knockout/Libraries/knockout/knockout.d.ts" />
ko.bindingHandlers["SDL.UI.Controls.Knockout.LineGraph"] = ko.bindingHandlers["lineGraph"];
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/TextInput/TextInput.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.TextInput, "SDL.UI.Controls.Knockout.TextInput");
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.DatePicker, "SDL.UI.Controls.Knockout.DatePicker");SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.LibraryPanel, "SDL.UI.Controls.Knockout.LibraryPanel");/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/Checkbox/Checkbox.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.Checkbox, "SDL.UI.Controls.Knockout.Checkbox");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/RadioButton/RadioButton.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.RadioButton, "SDL.UI.Controls.Knockout.RadioButton");
/// <reference path="../../SDL.Client.UI.Core.Knockout/Controls/Base.d.ts" />
/// <reference path="../../SDL.Client.UI.Controls/DropdownList/DropdownList.d.ts" />
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.DropdownList, "SDL.UI.Controls.Knockout.DropdownList");
/// <reference path="../../../SDL.Client.Core/Application/Application.d.ts" />
/// <reference path="../../../SDL.Client.UI.Core.Knockout/ViewModels/ViewModelBase.d.ts" />
/// <reference path="../../../SDL.Client.UI.Controls/TopBar/Application/TopBar.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var SDL;
(function (SDL) {
    (function (UI) {
        (function (Controls) {
            (function (Knockout) {
                (function (Application) {
                    (function (ViewModels) {
                        ;

                        eval(SDL.Client.Types.OO.enableCustomInheritance);
                        var TopBar = (function (_super) {
                            __extends(TopBar, _super);
                            function TopBar(ribbonTabs, selectedRibbonTabId, buttons) {
                                _super.call(this);

                                this.ribbonTabs = ko.observableArray(ribbonTabs || []);
                                this.selectedRibbonTabId = ko.isObservable(this.selectedRibbonTabId) ? selectedRibbonTabId : ko.observable(selectedRibbonTabId);
                                this.buttons = buttons;
                            }
                            TopBar.prototype.$initialize = function () {
                                SDL.Client.Event.EventRegister.addEventHandler(SDL.UI.Controls.Application.TopBar, "*", this.getDelegate(this.onTopBarEvent));
                                this.computedOptions = ko.computed(this.getDelegate(this.pushTopBarOptions));
                            };

                            TopBar.prototype.pushTopBarOptions = function () {
                                var topBarOptions = {
                                    ribbonTabs: SDL.UI.Core.Knockout.Utils.unwrapRecursive(this.ribbonTabs),
                                    selectedRibbonTabId: this.selectedRibbonTabId(),
                                    buttons: SDL.UI.Core.Knockout.Utils.unwrapRecursive(this.buttons)
                                };
                                SDL.UI.Controls.Application.TopBar.setOptions(topBarOptions);
                                return topBarOptions;
                            };

                            TopBar.prototype.onTopBarEvent = function (e) {
                                switch (e.type) {
                                    case "ribbonselectionchange":
                                        this.selectedRibbonTabId(e.data.id);
                                        break;
                                    case "clickbutton":
                                        if (e.data.button == "close" && this.onCloseClick) {
                                            this.onCloseClick();
                                        }
                                        break;
                                    case "showbutton":
                                        var buttonOptions = this.buttons[e.data.button];
                                        if (buttonOptions) {
                                            if (e.data.button == "close") {
                                                if (ko.isObservable(this.buttons.close)) {
                                                    this.buttons.close(true);
                                                }
                                            } else if (ko.isObservable(buttonOptions.hidden)) {
                                                buttonOptions.hidden(false);
                                            }
                                        }
                                        break;
                                    case "hidebutton":
                                        var buttonOptions = this.buttons[e.data.button];
                                        if (buttonOptions) {
                                            if (e.data.button == "close") {
                                                if (ko.isObservable(this.buttons.close)) {
                                                    this.buttons.close(false);
                                                }
                                            } else if (ko.isObservable(buttonOptions.hidden)) {
                                                buttonOptions.hidden(true);
                                            }
                                        }
                                        break;
                                    case "selectbutton":
                                        var buttonOptions = this.buttons[e.data.button];
                                        if (buttonOptions && ko.isObservable(buttonOptions.selected)) {
                                            buttonOptions.selected(true);
                                        }
                                        break;
                                    case "unselectbutton":
                                        var buttonOptions = this.buttons[e.data.button];
                                        if (buttonOptions && ko.isObservable(buttonOptions.selected)) {
                                            buttonOptions.selected(false);
                                        }
                                        break;
                                    case "positionbutton":
                                        var buttonOptions = this.buttons[e.data.button];
                                        if (buttonOptions) {
                                            if (ko.isObservable(buttonOptions.position.left)) {
                                                buttonOptions.position.left(e.data.position.left);
                                            }
                                            if (ko.isObservable(buttonOptions.position.right)) {
                                                buttonOptions.position.right(e.data.position.right);
                                            }
                                        }
                                        break;
                                }
                            };
                            return TopBar;
                        })(SDL.UI.Core.Knockout.ViewModels.ViewModelBase);
                        ViewModels.TopBar = TopBar;

                        TopBar.prototype.disposeInterface = SDL.Client.Types.OO.nonInheritable(function disposeInterface() {
                            var _this = this;

                            if (_this.computedOptions) {
                                _this.computedOptions.dispose();
                                _this.computedOptions = null;
                            }
                        });

                        SDL.Client.Types.OO.createInterface("SDL.UI.Controls.Knockout.Application.ViewModels.TopBar", TopBar);
                    })(Application.ViewModels || (Application.ViewModels = {}));
                    var ViewModels = Application.ViewModels;
                })(Knockout.Application || (Knockout.Application = {}));
                var Application = Knockout.Application;
            })(Controls.Knockout || (Controls.Knockout = {}));
            var Knockout = Controls.Knockout;
        })(UI.Controls || (UI.Controls = {}));
        var Controls = UI.Controls;
    })(SDL.UI || (SDL.UI = {}));
    var UI = SDL.UI;
})(SDL || (SDL = {}));
SDL.UI.Core.Knockout.Controls.createKnockoutBinding(SDL.UI.Controls.TreeView, "SDL.UI.Controls.Knockout.TreeView");
